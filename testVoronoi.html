<html>
	<head>
		<script src="https://rawgithub.com/mrdoob/three.js/master/build/three.js"></script> 
		<script src="resources/jquery-1.11.0.min.js"></script>
		<script src="resources/OrbitControls.js"></script>
		<script src = "resources/voronoi-core.min.js"></script>
	</head>	

	<body>
		<script>
		</script>
		<script>
			var scene;
			var camera;
			var renderer;
			var frameCount = 0;
			var controls;

			function VoronoiDiagram(pts) {
				var maxX = -1;
				var maxY = -1;
			
				for (var i = 0; i < pts.length; i++) {
					var p = pts[i];
					if (p.x > maxX) {
						maxX = p.x;
				}
					if (p.y > maxY) {
						maxY = p.y;
					}
				} 
				
				this.voronoi = new Voronoi();
				console.log("max x = " + maxX + " maxy = " + maxY);
				var bbox = {xl:0, xr:maxX, yt:0, yb:maxY};
				this.diagram = this.voronoi.compute(pts, bbox);	
				console.log(this.diagram.cells[0]);
			}

			VoronoiDiagram.prototype.initScene = function () {
				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera( 75, 
									window.innerWidth / window.innerHeight,
									0.1,
									1000 );
				controls = new THREE.OrbitControls(camera);
				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor(0xffffff, 1);
				renderer.setSize( window.innerWidth, window.innerHeight);
				$(renderer.domElement).css("position", "fixed");
				$(renderer.domElement).css("top", "100px");
				$(renderer.domElement).css("left", "0px");
				document.body.appendChild( renderer.domElement );


				var sphereGeom = new THREE.SphereGeometry(0.2, 24,24);
				var mat = new THREE.MeshBasicMaterial({color:0xff0000, transparent:true, opacity:0.5});
				var sphere = new THREE.Mesh(sphereGeom, mat);
				scene.add(sphere);
				camera.position.set(0.5, 1, 0);
				
				/*var XaxisMat = new THREE.LineBasicMaterial({color:0xff0000});
				var YaxisMat = new THREE.LineBasicMaterial({color:0x00ff00});
				var ZaxisMat = new THREE.LineBasicMaterial({color:0x0000ff});

				var xGeom = new THREE.Geometry();
				var yGeom = new THREE.Geometry();
				var zGeom = new THREE.Geometry();

				xGeom.vertices.push(new THREE.Vector3(-10, 0, 0));
				xGeom.vertices.push(new THREE.Vector3(-10, 0, 0));
				var X = new THREE.Line(xGeom, XaxisMat);
				scene.add(X);	

				yGeom.vertices.push(new THREE.Vector3(0, -10, 0));
				yGeom.vertices.push(new THREE.Vector3(0, 10, 0));
				var Y = new THREE.Line(yGeom, YaxisMat);
				scene.add(Y);
				
				zGeom.vertices.push(new THREE.Vector3(0, 0, -10));
				zGeom.vertices.push(new THREE.Vector3(0, 0, 10));
				var Z = new THREE.Line(zGeom, ZaxisMat);
				scene.add(Z);	*/


				this.createDiagram();
				animate();
			}

			function animate() {
				requestAnimationFrame(animate);
				render();
			}

			function render() {
				renderer.render(scene, camera);
				frameCount++;
			}
		
			function calculateNormal(v1,v2,v3) {
				var v1v2 = new THREE.Vector3();
				var v1v3 = new THREE.Vector3();
				v1v2.subVectors(v2, v1);
				v1v3.subVectors(v3, v1);

				var normal = new THREE.Vector3();
				normal.crossVectors(v1v2,v1v3);
				normal.normalize();
				return normal;
			}
	
			function lineGeometry(start, end, thickness) {
				var geometry = new THREE.Geometry();
				var slopeDenom = end.x - start.x;
				var offsetx, offsety;
				if (slopeDenom == 0) {
					offsety = 0;
					offsetx = thickness;
				}
				else {
					var slope = (end.y - start.y)/slopeDenom;
					if (slope > 0) {
						offsetx = thickness/Math.sqrt(2);
						offsety = -offsetx;
					}
					else if (slope < 0) {
						offsety = -thickness/Math.sqrt(2);
						offsetx = offsety;
					}
					else {
						offsetx = 0;
						offsety = thickness;
					}
				}	

				console.log("slopeDenom = " + slopeDenom);
				var v1 = new THREE.Vector3(start.x, 0, start.y);
				var v2 = new THREE.Vector3(end.x, 0, end.y);
				var v3 = new THREE.Vector3(end.x + offsetx, 0, end.y + offsety);
				var v4 = new THREE.Vector3(start.x + offsetx, 0, start.y + offsety);
					
				var v5 = new THREE.Vector3(start.x, thickness, start.y);
				var v6 = new THREE.Vector3(end.x, thickness, end.y);
				var v7 = new THREE.Vector3(end.x + offsetx, thickness, end.y + offsety);
				var v8 = new THREE.Vector3(start.x + offsetx, thickness, start.y + offsety);
				
				geometry.vertices.push(v1);
				geometry.vertices.push(v2);
				geometry.vertices.push(v3);
				geometry.vertices.push(v4);

				geometry.vertices.push(v5);
				geometry.vertices.push(v6);
				geometry.vertices.push(v7);
				geometry.vertices.push(v8); 

				// bottom: v1, v2, v3, v4
				geometry.faces.push(new THREE.Face3(0, 1, 2));
				var n1 = calculateNormal(v1, v2, v3);
				geometry.faces[0].normal = n1;

				geometry.faces.push(new THREE.Face3(2, 3, 0));
				geometry.faces[1].normal = n1;

				// top: v5, v6, v7, v8
				geometry.faces.push(new THREE.Face3(4, 7, 6));
				var n2 = calculateNormal(v5, v8, v7);
				geometry.faces[2].normal = n2;

				geometry.faces.push(new THREE.Face3(6, 5, 4));
				geometry.faces[3].normal = n2;

				// up: v5, v6, v2, v1
				geometry.faces.push(new THREE.Face3(4, 5, 1));
				var n3 = calculateNormal(v5, v6, v2);
				geometry.faces[4].normal = n3;

				geometry.faces.push(new THREE.Face3(1, 0, 4));
				geometry.faces[5].normal = n3;

				// down: v4, v3 v7, v8
				geometry.faces.push(new THREE.Face3(3, 2, 6));
				var n4 = calculateNormal(v4, v3, v7);
				geometry.faces[6].normal = n4;

				geometry.faces.push(new THREE.Face3(6, 7, 3));
				geometry.faces[7].normal = n4;

				// left: v1, v5, v8, v4
				geometry.faces.push(new THREE.Face3(0, 4, 7));
				var n5 = calculateNormal(v1, v5, v8);
				geometry.faces[8].normal = n5;

				geometry.faces.push(new THREE.Face3(7, 3, 0));
				geometry.faces[9].normal = n5;

				// right: v2, v6, v7, v3
				geometry.faces.push(new THREE.Face3(1, 5, 6)); 
				var n6 = calculateNormal(v2, v6, v7);
				geometry.faces[10].normal = n6;

				geometry.faces.push(new THREE.Face3(6, 2, 1)); 
				geometry.faces[11].normal = n6;
				return geometry;
			}

	
			VoronoiDiagram.prototype.createDiagram = function() {
				var cells = this.diagram.cells;
				var logged = false;

				var testStart = {x:-0.5, y:0};
				var testEnd = {x:0.5, y:0};
				var testLineGeom = lineGeometry(testStart,testEnd, 0.5);
				console.log(testLineGeom);
				var mat = new THREE.MeshBasicMaterial({color:0xff0000});
				var testLine = new THREE.Mesh(testLineGeom, mat);
				scene.add(testLine);
				
			//	for (var i = 0; i < cells.length; i++) {
				for (var i = 0; i < 0; i++) {
					// get next site
					var halfedges = cells[i].halfedges;

					// add each edge to mesh
					for (var j = 0; j < halfedges.length; j++) {
					//for (var j = 0; j < 1; j++) {
						var edge = halfedges[j];
						var start = edge.getStartpoint();
						var end = edge.getEndpoint();
						var angle = 0;
	
						var slopeDenom = end.x - start.x;
						if (slopeDenom == 0) {
							angle = Math.PI / 2;	
						} 
						else {
							var dx = start.x - end.x;
							var dy = start.y - end.y;
							angle = -1 * Math.atan(dy/dx);	

							/*console.log("values : ");
							console.log(start);
							console.log(end);
							console.log(angle); */
						}
	
						// bottom
						var d = 0.01;
						var w = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
						var h = 0.01;
						var geometry = new THREE.CubeGeometry(w,h,d);
				
						var t1 = new THREE.Matrix4();
						var firsttrans;

						t1.makeTranslation(w/2,0,0);
						geometry.applyMatrix(t1);

						var translate = new THREE.Matrix4();
						translate.makeTranslation(start.x , 0,start.y);
						
						var rotate = new THREE.Matrix4();
						rotate.makeRotationY(angle);

						geometry.applyMatrix(rotate);
						geometry.applyMatrix(translate);
						
						var linegeometry = new THREE.Geometry();
						linegeometry.vertices.push(new THREE.Vector3(start.x, 0, start.y));
						linegeometry.vertices.push(new THREE.Vector3(end.x, 0, end.y));
						var linemat = new THREE.LineBasicMaterial({color:0xff0000});
						var line = new THREE.Line(linegeometry,linemat);
						scene.add(line);

						if (!logged) {
							console.log(geometry.vertices);
							console.log(linegeometry.vertices);
							logged = true;
						}

						var p1 = geometry.vertices[0];
						var p2 = linegeometry.vertices[0];
						var dist = Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
						var material;
						if (dist > 0.1) {
/*							console.log("dist = " + dist);
							console.log(geometry.vertices);
							console.log(linegeometry.vertices); */
							material = new THREE.MeshBasicMaterial({color:0xffff00});
						}

						else {
							material = new THREE.MeshLambertMaterial({color: 0x0000ff, transparent: true, opacity: 0.5});
						}
						var nextLine = new THREE.Mesh(geometry, material);
						scene.add(nextLine); 
					}

				}
			
				/*var canvas = document.getElementById('canvas');	
				var ctxt = canvas.getContext('2d');
				canvas.width = 800;
				canvas.height = 800;
				ctxt.strokeStyle = "#00ff00";
				console.log("numcells = " + cells.length);
				ctxt.fillStyle = "#ff0000";
				ctxt.rect(0, 0, 800, 800);
				ctxt.fill();
				for (var i = 0; i < cells.length; i++) {
					var halfedges = cells[i].halfedges;	
					ctxt.beginPath();
	
					for(var j = 0; j < halfedges.length; j++) {
						var edge = halfedges[j];						
						var start = edge.getStartpoint();
						var end = edge.getEndpoint();
						ctxt.moveTo(start.x, start.y);
						ctxt.lineTo(end.x, end.y);
						ctxt.stroke();
					}
				}*/
			}
			
			$(document).ready(function(){
				var pts = [];


				for (var i = 0; i < 100; i++) {
					var x = Math.random();
					var y = Math.random();
					pts.push({x:x, y:y});
				}

				var v = new VoronoiDiagram(pts);
				v.initScene();
			});

		</script>
		<h1>Test Voronoi</h1>
		<canvas id="canvas"></canvas>	
	</body>
</html>
